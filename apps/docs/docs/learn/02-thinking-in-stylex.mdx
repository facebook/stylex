---
# Copyright (c) Meta Platforms, Inc. and affiliates.
#
# This source code is licensed under the MIT license found in the
# LICENSE file in the root directory of this source tree.
sidebar_position: 2
---

# Thinking in StyleX

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Core Principles

To understand why StyleX exists and the reasoning behind its decisions, it may be beneficial to familiarize oneself with the fundamental principles that guide it. This may help you decide if StyleX is the right solution for you.

These principles should also be helpful when designing new APIs for StyleX.

### Co-location

There are benefits to making your code DRY, but we don't think that's true when it comes to writing your styles.

The best and most readable way to write your styles is to write them in the same
file as the markup where you use them. Repeating yourself is not a bad thing
when it comes to styles.

StyleX is designed to let you author, apply and reason about your styles
locally.

### Deterministic resolution

CSS is a powerful and expressive language. However, it can sometimes
feel fragile. Some of this stems from a misunderstanding of how CSS works, but a
lot of it stems from the discipline and organization required to keep your CSS
selectors with different specificities from stepping on each other's toes.

Most existing solutions to this problem rely on rules and conventions.

<details>
  <summary>BEM and OOCSS Conventions</summary>
  BEM and OOCSS introduce naming conventions to avoid these problems relying on
  developers to consistently follow the rules, frequently avoiding merging styles at all.
  This can lead to bloated CSS.
</details>

<details>
  <summary>Utility Classes</summary>
  Atomic utility class names like Tailwind CSS and Tachyons rely on a convention to ensure you don't
  apply conflicting class names on the same element. The tooling to enforce this rule relies on all
  your styles being present inline in the same string. This makes it harder to refactor your styles
  into separate groups and merge them within the same file or across file boundaries.
</details>

StyleX aims to improve on both the consistency and predictability of styles
_and_ the expressive power available. We believe this is possible through
build-tools.

StyleX provides a completely predictable and deterministic styling
system that works across files. It produces deterministic results not only when merging multiple selectors, but also when merging multiple shorthand and longhand properties. (e.g. `margin` vs `margin-top`).

> "The last style applied always wins."

### Low-cost Abstractions

When it comes to the performance cost of StyleX, our guiding principle is that
StyleX should always be the fastest way to achieve a particular pattern.
Unless you opt in to a feature, you should never pay for it with runtime
performance. We make the trade-off of doing more work at build-time to improve
runtime performance.

Here's how this plays out in practice:

#### 1. Styles created and applied locally

When authoring and consuming styles within the same file, the cost of StyleX is zero. This is because in addition to compiling away your `stylex.create` calls, StyleX also compiles away your `stylex.props` calls when possible.

So,

```tsx
import * as stylex from 'stylex';
const styles = stylex.create({
  red: {color: 'red'},
});
let a = stylex.props(styles.red);
```

Compiles down to:

<Tabs>
<TabItem label="JS Output" value="js-output">

```tsx
import * as stylex from 'stylex';

let a = {className: 'x1e2nbdu'};
```

</TabItem>
<TabItem label="CSS Output" value="css-output">

```css
.x1e2nbdu {
  color: red;
}
```

</TabItem>
</Tabs>

There is no runtime overhead here.

#### 2. Using styles across files

When passing styles across file boundaries, you pay a small cost for the
additional power and expressivity. The `stylex.create` call is not deleted
entirely and instead leaves behind an object mapping keys to
class names. And the `stylex()` or `stylex.props()` calls are executed at
runtime.

This code, for example:

```tsx
import * as stylex from '@stylexjs/stylex';

const styles = stylex.create({
  foo: {
    color: 'red',
  },
  bar: {
    backgroundColor: 'blue',
  },
});

function MyComponent({xstyle}) {
  return <div {...stylex.props(styles.foo, styles.bar, xstyle)} />;
}
```

Compiles down to:

```tsx
import * as stylex from '@stylexjs/stylex';

const styles = stylex.create({
  foo: {
    color: 'x1e2nbdu',
    $$css: true,
  },
  bar: {
    backgroundColor: 'x1t391ir',
    $$css: true,
  },
});

function MyComponent((xstyle)) {
  return <div {...stylex.props(styles.foo, styles.bar, xstyle)} />;
}
```

This definitely a little more code, but the runtime cost is still minimal
because of how fast the `stylex()` and `stylex.props()` functions are.

Most other styling solutions don't enable composition of styles across file
boundaries. The state of the art is to combine lists of class names.

### Small API Surface

Our goal is to make StyleX as minimal and easy-to-learn as possible. As such we
don't want to invent too many APIs. Instead, we want to be able to lean on 
common JavaScript patterns where possible and give you the smallest API surface
possible.

At its core StyleX can be boiled down to two functions:

1. `stylex.create`
2. `stylex.props`

You use `stylex.create` to create a bunch of styles and then you use
`stylex.props` to apply those styles to an element.

Within these two functions, we choose to rely on common JS patterns rather than
introduce unique API or patterns for StyleX. e.g. we don't have an API for
conditional styles. Instead we let you apply styles conditionally with
boolean expression or ternary expressions.

Things work the way you expect when dealing with JavaScript objects and arrays.
There are no surprises.

### Type-Safe Styles

Typescript has becomes massively popular due to the experience and safety it
provides. Our styles, however, have largly remained untyped and unreliable.
Except for some path-breaking projects such as
[Vanilla Extract](https://vanilla-extract.style/), styles are just bags of
strings in most styling solutions.

StyleX is authored in Flow with strong static types. It's packages on NPM come
with auto-generated types for both Flow and TypeScript. When there are
incompatibilies between the two type-systems we take the time to ensure that we
write custom Typescript types to achieve the same level of power and safety as
the original Flow.

_All styles are typed_. When accepting styles as props, you can use types to
constrain what styles you will accept. Styles should be as type-safe as
any other props for your components.

The StyleX API is strongly typed. Every style you author has types as well. This is
only really possible because we use JavaScript objects to author `RawStyles`.

These types can then be leveraged to set contracts for the styles that your
component will accept You may make a component that only accepts
`color` and `backgroundColor` but no other styles.

```ts
import type {StyleXStyles} from '@stylexjs/stylex';

type Props = {
  //...
  style?: StyleXStyles<{color?: string; backgroundColor?: string}>;
  //...
};
```

In another example, you may disallow margins while allowing any other styles:

```ts
import type {StyleXStylesWithout} from '@stylexjs/stylex';

type Props = {
  //...
  style?: StyleXStylesWithout<{
    margin: unknown;
    marginBlock: unknown;
    marginInline: unknown;
    marginTop: unknown;
    marginBottom: unknown;
    marginLeft: unknown;
    marginRight: unknown;
    marginBlockStart: unknown;
    marginBlockEnd: unknown;
    marginInlineStart: unknown;
    marginInlineEnd: unknown;
  }>;
  //...
};
```

Your styles being typed allows you to set up extremely sophisticated rules
about the ways in which a component styles can be customized with **zero-runtime
cost**.

**Strings don't have Types**. By using JavaScript objects for styles, we retain
type information when you define styles.

### Shareable constants

CSS class names, CSS variables and other CSS identifiers are defined in a global
namespace. The obvious and common API to bring them into JavaScript is as
strings. However, this means losing type-safety and composability.

We want styles to be type-safe and so we've spent a lot of time coming up with
APIs to replace these magic strings with references to Javacript constants. So
far this is reflected in the following APIs:

1. `stylex.create` Abstracts away the generated class names entirely. You deal
   with "opaque" JavaScript objects with strong types to indicate the styles
   they represent.
2. `stylex.defineVars` Abstracts away the names of CSS variables generated. You
   import and use them as constants in your styles directly. The type of values
   these variables represent is maintained in the typesystem.
3. `stylex.keyframes` Abstracts away the names of keyframe animations. Instead
   you declare them as constants and use them by reference.

We're looking into ways to make other CSS identifiers such as
`container-name` and `@font-face` type-safe as well.

### Framework-agnostic

StyleX is a CSS-in-JS solution, not a CSS-in-React solution. Although StyleX
been tailored to works best with React today, It's designed to be used with any
JavaScript framework that lets you author your markup in your Javacript.

`stylex.props` returns an object with `className` and `style` properties. You
may need to use a wrapper function to convert this to make it work with your
framework of choice.

### Encapsulation

> All styles on an element should be caused by class names on that element
> itself.

CSS makes it very easy to author styles in a way that let you cause "styles at a
distance":

- `.className > *`
- `.className ~ *`
- `.className:hover > div:first-child`

All of these patterns, while powerful, makes your styles fragile and harder to
debug. You apply class names on one element and affect a completely different
element.

Inheritable styles such as `color` will still be inherited, but that is the
_only_ form of style-at-a-distance that StyleX allows. And in those cases too,
the styles applied directly on an element always take precedence over inherited
styles.

This is often not the case when using complex selectors as the complex selectors
usually have higher specificity than the simple classname selectors used for
styles applied directly on the element.

StyleX disallows this entire class of selectors. This currently makes some
patterns in CSS impossible:

- e.g. It is currently impossible for a child element to have conditional styles
  when it's parent is hovered.

Our goal is to support these patterns without sacrificing style encapsulation.

StyleX is not CSS pre-processor. It intentionally puts constraints on the power
of CSS selectors in order to give you a fast and predictable system.

Using a JavaScript object as an API transparently nudges you into writing valid
styles, as writing complex selectors _feels_ out of place.

An API that allows template strings signals a freedom where developers
would naturally start writing arbitrary CSS and expect it to _just work_. Such
expectations are incompatible with the way StyleX actually works. In order to
mitigate this issue, one would need to do aggressive validation with ESlint and
Babel.

This would lead to an unpleasant experience where the API guides you in one
direction while the tooling gets noisy and tries to keep you within the bounds.

### Readability & Maintainabity over Terseness

Many recent styling solutions are extremely terse and easy to write. Tailwind
CSS is popular and lets you author your styles by putting extremely terse
utility class names directly on your markup. This is great for authoring styles
quickly, but in our opinion, in the long run, it makes the styles harder to read
and maintain. It can also have a steeper learning curve up-front.

StyleX makes the choice to use the same CSS property names that you're already
used to. _(We did decide to use camelCase instead of kebab-case as that makes
them easier to type in JavaScript.)_ This makes it easier to learn and read.

We also enforce that your styles are authored in objects separate from the HTML
elements where you use them. We made this decision to help with the readabiliy
of your HTML markup and so you can choose appropriate names for your styles to
indicate their purpose. `styles.active` tells you much more about the purpose of
a bunch of styles than what those styles are themselves.

This principle leads to trade-offs where authoring styles may take more typing
with StyleX than some other solutions. You're also forced to name your style
objects when styling new elements.

We believe these costs are worth the improved readability over time. Giving each
HTML element a semantic name can communicate a lot more than the styles
themselves.

:::info

One side benefit of using references to styles rather than using the styles
inline is **testability**. In a unit-testing environment, StyleX can be
configured to remove all atomic styles and only output single debugging
class names to show you the source of the styles applied to an element.

Among other benefits, it makes snapshot tests more resilient as they won't
change for every style change.

:::

### Modularity and Composability

NPM has made it extremely easy to share code across projects. However, sharing
CSS has remained a challenge.

When using third-party components, you generally have to either choose between
components with styles baked in that are hard or impossible to customize, or
"headless" components that are completely unstyled.

The lack of a good system to predictably merge and compose styles across
packages has also been an obstacle when sharing styles within packages.

StyleX aims to create a system to easily and reliably share styles along with
components within packages on NPM.

### Avoiding Global Configuration

In order to make styles modular and composable, we worked to avoid
configuration where possible. StyleX should work with no configuration out of
the box which should ensure that styles from different packages don't conflict
with each other.

Many other styling solutions offer a way to create project-specific
configurations. You're able to define common tokens, breakpoints and other
shorthand in such configurations. We have chosen to eschew such configurations
to prioritise composability over convenience.

In order to provide some of the benefits of such global configurations, we allow
declaring styles and variables in modules that you can import and use. We're
also working on configurable ESlint rules that will let you enforce
project-specific style conventions without changing the behaviour of StyleX
itself.

### One small file over many smaller files

Most styling solutions lead to CSS that grows linearly with the size of your
codebase. For larger applications it makes loading all your CSS upfront
infeasible. So you end up splitting your CSS into multiple files and loading
them lazily as you need them.

This improves your initial load time and performance, but it comes at the cost
of slower updates as the browser needs to recalculate styles every time more CSS
is loaded.

With StyleX, we're aiming to create a system where the total amount of CSS is
small-enough that you can load all your CSS upfront without a significant
performance penalty.

The StyleX model doesn't make lazy-loading or critical-css impossible, but we
are not optimizing for it for now and are focusing on generating smallest,
fastest single CSS bundle possible.

## Ideal conditions for using StyleX?

StyleX works well in a wide variety of projects, and you will usually not regret
choosing it. However, there are some conditions that are more ideal for using StyleX than
others.

### When authoring your UI in JavaScript

StyleX is a CSS-in-JS library, which means that it is most useful when you are
authoring your UI in JavaScript. If you're using a framework such as React,
Preact, Solid, lit-html, or Angular, using StyleX should be a breeze.

Some frameworks, such as Svelte and Vue use custom file formats that are
compiled to JavaScript at build time. StyleX can still be used in these
frameworks, but may need some extra configuration.

There are also UI solutions such as `htmx` and various templating engines where
you author your markup in files that can't contain arbitrary JavaScript. Even if
you can make StyleX work in these environments, it may not be worth the effort.

### Large or growing projects

While StyleX works well for projects of all sizes, it really shines in larger
applications.

Since StyleX compiles to atomic class names, a big performance benefit is that
the size of your CSS bundle plateaus as your project grows.

For smaller projects, it may still make sense to choose StyleX for its
expressive API, but the performance benefits may not be as meaningful.

### Reusable components

StyleX makes the most sense when being used alongside reusable UI components.

For years, we have had to choose between "Design System" components that come
with styles baked in but can be difficult to customize or "Headless" components
that are completely unstyled.

StyleX finally lets you build UI components that can have default styles _and_
still be customizable.

Further, the consistency enables sharing these components by publishing them to
NPM. As long as the consumer of your component is also using StyleX, the styles
will be merged and composed correctly without any additional configuration.
