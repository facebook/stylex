---
sidebar_position: 2
---

# Thinking in StyleX

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Core Principles

To understand why StyleX exists why it makes the decisions it does, it may be
helpful to understand the core principles that guide it. This may help guide
your decision to decide if StyleX is the right solution for you.

These principles should also be helpful when designing new APIs for StyleX.

### Deterministic resolution

CSS is a powerful and extremely expressive language. However, it can sometimes
feel fragile. Some of this stems from a misunderstanding how CSS works, but a
lot of it stems from the discipline and organization required to keep your CSS
selectors with different specificities from stepping on each other's toes.

Most existing solutions to this problem rely on rules and conventions.

<details>
  <summary>BEM and OOCSS Conventions</summary>
  BEM and OOCSS introduce naming conventions such that we don't run into many of
  these problems. But it puts the burden on the developer to follow the rules and
  it mostly just tells you not to merge styles at all. This can lead to bloated CSS.
</details>

<details>
  <summary>Utility Classes</summary>
  Atomic utility classNames like Tailwind CSS and Tachyons relies on a convention
  to ensure you don't apply conflicting classNames on the same element. The tooling
  to enforce this rule relies on all your styles being present inline in the same
  string. This makes it harder to refactor your styles into separate groups and merge
  them. Within the same file or across file boundaries.
</details>

StyleX aims to improve on both the consistency and predictability of styles
_and_ the expressive power available. We believe this is possible through
build-tools.

StyleX aims to give you a completely predictable and deterministic styling
system that works across files. And we aim to not only give you deterministic
results when merging multiple selectors, but also when merging multiple
shorthand and longhand properties. (e.g. `margin` vs `margin-top`).

> "The last style applied always wins."

### Low-cost Abstractions

When it comes to performance cost of StyleX, our guiding principle is that
StyleX should always be the fastest way to achieve a particular pattern. I.e.
Unless you opt into a feature, you should never pay for it with runtime
performance. We make the trade-off of doing more work at build-time to improve
runtime performance.

Here's how this plays out in practice:

#### 1. Styles created and applied locally

If you authors styles within a file and then consume all those styles in the
same file, the cost of StyleX is zero. This is because in addition to compiling
away your `stylex.create` calls, StyleX also compiles away your `stylex.props` calls
when possible.

So,

```tsx
import * as stylex from 'stylex';
const styles = stylex.create({
  red: {color: 'red'},
});
let a = stylex.props(styles.red);
```

Compiles down to just:

<Tabs>
<TabItem label="JS Output" value="js-output">

```tsx
import * as stylex from 'stylex';

let a = {className: 'x1e2nbdu'};
```

</TabItem>
<TabItem label="CSS Output" value="css-output">

```css
.x1e2nbdu {color: red}
```

</TabItem>
</Tabs>

There is no runtime overhead here.

#### 2. Using styles across files

When passing styles across file boundaries, you pay a small cost for the
additional power and expressivity. The `stylex.create` call is not deleted
entirely and instead leaves behind very simple object mapping keys to
classNames. And the `stylex()` or `stylex.props()` calls are executed at
runtime.

This code, for example:

```tsx
import * as stylex from '@stylexjs/stylex';

const styles = stylex.create({
  foo: {
    color: 'red',
  },
  bar: {
    backgroundColor: 'blue',
  },
});

function MyComponent({xstyle}) {
  return <div {...stylex.props([styles.foo, styles.bar, xstyle])} />;
}
```

Compiles down to:

```tsx
import * as stylex from '@stylexjs/stylex';

const styles = stylex.create({
  foo: {
    color: 'x1e2nbdu',
    $$css: true,
  },
  bar: {
    backgroundColor: 'x1t391ir',
    $$css: true,
  },
});

function MyComponent((xstyle)) {
  return <div {...stylex.props([styles.foo, styles.bar, xstyle])} />;
}
```

This definitely a little more code, but the runtime cost is still minimal
because of how fast the `stylex()` and `stylex.props()` functions are.

Most other styling solutions don't enable composition of styles across file
boundaries. The state of the art is to combine lists of classNames.

### Small API Surfaces

Our goal is to make StyleX feel simple and obvious. As such we don't want to
invent too many APIs. Instead, we want to be able to lean on common Javascript
patterns where possible and give you the smallest API surface possible.

At it's core StyleX can be boiled down to just two functions:

1. `stylex.create`
2. `stylex.props`

You use `stylex.create` to create a bunch of styles and then you use
`stylex.props` to apply those styles to an element.

Other than the fact that `stylex.create` takes static values, you don't really
need to learn anything else about how StyleX works. Things work the way you
expect when dealing with JavaScript objects and arrays. No surprises.

Within these two functions, we choose to rely on common JS patterns rather than
introduce unique API or patterns for StyleX. e.g. we don't have an API for
conditional styles. Instead we let you apply styles conditionally with a `&&`
boolean expression or ternary expressions. For variants, we recommend using a
computed key access on the styles object. `styles[variant]`.

### Co-location of Styles and Markup

There are benefits to making your code DRY, but we don't think that's true when
it comes to writing your styles.

The best and most readable way to write your styles is to write them in the same
file as the markup where you use them. Repeating yourself is not a bad thing
when it comes to styles.

StyleX enables you to write your styles in every file where you use them and
repeat yourself as many times as you want and it automatically de-duplicates all
the generated CSS to give you the smallest CSS bundle possible.

### Type-Safe styles

Typescript has becomes massively popular due to the experience and safety it
provides. Our styles, however, have largly remained untyped and unreliable.
Except for some path-breaking projects such as
[Vanilla Extract](https://vanilla-extract.style/), styles are just bags of
strings in most styling solutions.

StyleX is authored in Flow with strong static types. It's packages on NPM come
with auto-generated types for both Flow and TypeScript. When there are
incompatibilies between the two type-systems we take the time to ensure that we
write custom Typescript types to achieve the same level of power and safety as
the original Flow.

_All styles are typed_. When accepting styles as props, you can use types to
constrain what you will and will not accept. Styles should be as type-safe as
any other props for your components.

The StyleX API is strongly typed. Every style you author has types too. This is
only really possible because we use Javascript objects to author `RawStyles`.

These types can then be leveraged to set contracts for the styles that your
component may or may not accept. You may make a component that only accepts
`color` and `backgroundColor` but no other styles.

```ts
import type {StyleXStyles} from '@stylexjs/stylex';

type Props = {
  //...
  style?: StyleXStyles<{color?: string; backgroundColor?: string}>;
  //...
};
```

In another example, you may disallow margins while allowing any other styles:

```ts
import type {StyleXStylesWithout} from '@stylexjs/stylex';

type Props = {
  //...
  style?: StyleXStylesWithout<{
    margin: unknown;
    marginBlock: unknown;
    marginInline: unknown;
    marginTop: unknown;
    marginBottom: unknown;
    marginLeft: unknown;
    marginRight: unknown;
    marginBlockStart: unknown;
    marginBlockEnd: unknown;
    marginInlineStart: unknown;
    marginInlineEnd: unknown;
  }>;
  //...
};
```

Your styles being typed allows you to set up some extremely sophisticated rules
about the ways in which a component styles can be customized with **zero-runtime
cost**.

**Strings don't have Types**. By using JavaScript objects for styles, we retain
type information when you define styles.

### Shareable constants

CSS classNames, CSS variables and other CSS identifiers are defined in a global
namespace. The obvious and common API to bring them into javascript is as
strings. However, this means losing type-safety and composition.

We want styles to be type-safe and so we've spent a lot of time coming up with
APIs to replace these magic strings with references to Javacript constants. So
far this is reflected in the following APIs:

1. `stylex.create` abstracts away the generated classNames entirely. You deal
   with "opaque" javascript objects with strong types to indicate the styles
   they represent.
2. `stylex.defineVars` abstracts away the names of CSS variables generated. You
   import and use them as constants in your styles directly. The type of values
   these variables represent is maintained in the typesystem.
3. `stylex.keyframes` abstracts away the names of keyframe animations. Instead
   you declare them as constants and use them by reference.

We're looking into APIs to ways to make other CSS identifiers such as
`container-name`, `@font-face` etc type-safe as well.

### Framework-agnostic

StyleX is a CSS-in-JS solution, not a CSS-in-React solution. Although StyleX
been tailored to works best with React today, It's designed to be used with any
Javascript framework that lets you author your markup in your Javacript.

`stylex.props` returns an object with `className` and `style` properties. You may
need to use a wrapper function to convert this to make it work with your framework
of choice.

### Encapsulation over Expressivity

> All styles on an element should be caused by classNames on that element
> itself.

CSS makes it very easy to author styles in a way that let you cause "styles at a
distance":

- `.className > *`
- `.className ~ *`
- `.className:hover > div:first-child`

All of these patterns, while powerful, makes your styles fragile and harder to
debug. You apply classNames on one element and affect a completely different
element.

Inheritable styles such as `color` will still be inherited, but that is the
_only_ form of style-at-a-distance that StyleX allows. And in those cases too,
the styles applied directly on an element always take precedence over inherited
styles.

This is often not the case when using complex selectors as the complex selectors
usually have higher specificity than the simple classname selectors used for
styles applied directly on the element.

StyleX disallows this entire class of selectors. This currently makes some
patterns in CSS impossible:

- e.g. It is currently impossible for a child element to have conditional styles
  when it's parent is hovered.

Our goal is to support these patterns without sacrificing style encapsulation.

StyleX is not CSS pre-processor. It intentionally puts constraints on the power
of CSS selectors in order to give you a fast and predictable system.

Using a Javascript object as an API transparently nudges you into writing valid
styles as writing complex selectors _feel_ out of place.

An API that allowed template strings signals a kind of freedom where developers
would naturally start writing arbitrary CSS and expect it to _just work_. Such
expectations are incompatible with the way StyleX actually works. In order to
mitigate this issue, we would need to do aggressive validation within ESlint and
Babel.

This would lead to an unpleasant experience where API guides you in one
direction while the tooling gets noisy and tries to keep you within the bounds.

### Readability & Maintainabity over Terseness

Many recent styling solutions are extremely terse and easy to write. Tailwind
CSS is popular and lets you author your styles by putting extremely terse
utility classNames directly on your markup. This is great for authoring styles
quickly, but in our opinion, in the long run it makes the styles harder to read
and maintain. It can also have a steeper learning curve up-front.

StyleX makes the choice to use the same CSS property names that you're already
used to. _(We did decide to use camelCase instead of kebab-case as that makes
them easier to type in JavaScript.)_ This makes it easier to learn and read.

We also enforce that your styles are authored in objects separate from the HTML
elements where you use them. We made this decision to help with the readabiliy
of your HTML markup and so you can choose appropriate names for your styles to
indicate their purpose. `styles.active` tells you much more about the purpose of
a bunch of styles than what those styles are themselves.

This principle leads to trade-offs where authoring styles may take more typing
with StyleX than some other solutions. You're also forced to name your style
objects when styling new elements.

We believe these costs are worth the improved readability over time. Giving each
HTML element a semantic name can communicate a lot more than the styles
themselves.

:::info

One side benefit of using references to styles rather than using the styles
inline is **testability**. In a unit-testing environment, StyleX can be
configured to remove all atomic styles and only output single debugging
classNames to show you the source of the styles applied to an element.

Among other benefits, it makes snapshot tests more resilient as they won't
change for every style change.

:::

### Modularity and Composability

NPM has made it extremely easy to share code across projects. However, sharing
CSS has remained a challenge.

When using third-party components, you generally have to either choose
components with styles baked in that are hard or impossible to customize, or
"headless" components that are completely unstyled.

The lack of a good system to predictably merge and compose styles across
packages has also been an obstacle when sharing styles within packages.

StyleX aims to create a system to easily and reliably share styles along with
components within packages on NPM.

### Avoiding Global Configuration

In order to make styles modular and composable, we have worked to avoid
configuration where possible. StyleX should work with no configuration out of
the box which should ensure that styles from different packages don't conflict
with each other.

Many other styling solutions offer a way to create project-specific
configurations. You're able to define common tokens, breakpoints and other
shorthand in such configurations. We have chosen to eschew such configurations
to prioritise composability over convenience.

In order to provide some of the benefits of such global configurations, we allow
declaring styles and variables in modules that you can import and use. We're
also working on configurable ESlint rules that will let you enforce
project-specific style conventions without changing the behaviour of StyleX
itself.

### One small file over many smaller files

Most styling solutions lead to CSS that grows linearly with the size of your
codebase. For larger applications it makes loading all your CSS upfront
infeasible. So you end up splitting your CSS into multiple files and loading
them lazily as you need them.

This improves your initial load time and performance, but it comes at the cost
of slower updates as the browser needs to recalculate styles every time more CSS
is loaded.

With StyleX, we're aiming to create a system where the total amount of CSS is
small-enough that you can load all your CSS upfront without a significant
performance penalty.

The StyleX model doesn't make lazy-loading or critical-css impossible, but we
are not optimizing for it for now and are focusing on generating smallest,
fastest single CSS bundle possible.

## Ideal conditions for using StyleX?

StyleX works well in a wide variety of projects, and you will usually not regret
choosing it.

However, there are some conditions that are more ideal for using StyleX than
others.

### When authoring your UI in Javascript

StyleX is a CSS-in-JS library, which means that it is most useful when you are
authoring your UI in Javascript. If you're using a framework such as `React`,
`Preact`, `Solid`, `lit-html`, or `Angular`, using StyleX should be a breeze.

Some frameworks, such as Svelte and Vue use custom file formats that are compiled
to Javascript at build time. StyleX can still be used in these frameworks, but
may need some extra configuration.

There are also UI solutions such as `htmx` and various templating engines where
you author your markup in files that can't contain arbitrary Javascript. Even if
you can make StyleX work in these environments, it may not be worth the effort.

### Large or growing projects

While StyleX works well for projects of all sizes, it really shines in larger
applications.

Since StyleX compiles to atomic class names, a big performance benefit is that
the size of your CSS bundle plateaus as your project grows.

For smaller projects, it may still make sense to choose StyleX for its
expressive API, but the performance benefits may not be as meaningful.

### Reusable components

StyleX makes the most sense when being used alongside reusable UI components.

For years, we have had to choose between "Design System" components that come
with styles baked in but can be difficult to customize or "Headless" components
that are completely unstyled.

StyleX finally lets you build UI components that can have default styles _and_
still be customizable.

Further, the consistency enables sharing these components by publishing them to NPM.
As long as the consumer of your component is also using StyleX, the styles will
be merged and composed correctly without any additional configuration.
