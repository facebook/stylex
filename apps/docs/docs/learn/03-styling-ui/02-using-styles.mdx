---
sidebar_position: 2
---

# Using styles

Once styles have been defined, they can be converted to classNames using the
`stylex` function and used as the `className` prop of any HTML element.

```tsx
<div {...stylex.props(styles.base)} />
```

While this is the simplest case, it is trivial to merge multiple style objects,
use them conditionally, or even compose styles across module boundaries. We will
look at that next.

## Merging styles

As seen previously, you can use the `stylex` function to convert a style object
to a className string that can be used directly in your markup. However,
`stylex` function is more powerful than that and can be used to merge multiple
styles deterministically and based on the usage order.

Consider that a couple of style objects are defined as so:

```tsx
import * as stylex from '@stylexjs/stylex';

const styles = stylex.create({
  base: {
    fontSize: 16,
    lineHeight: 1.5,
    color: 'rgb(60,60,60)',
  },
  highlighted: {
    color: 'rebeccapurple',
  },
});
```

You can use the result of merging both style objects like so:

```tsx
<div {...stylex.props([styles.base, styles.highlighted])} />
```

:::info Like `Object.assign`

A simple way to think about the `stylex.props` function is that it does what
`Object.assign` does. It merges many objects and the later objects have
precedence over previous objects.

The actual implementation is optimized for performance.

:::

Here, it is important to note that the last styles in the list of styles passed
to the `stylex.props` function will always win. Styles are always resolved by
_application order_.

When in doubt, think about `Object.assign` or inline styles in HTML. The last
styles applied always wins.

## Conditional styles

The `stylex` function can also ignore falsy values such as `null`, `undefined`
or `false`. This ability can be used when you need to apply some styles
conditionally.

```tsx
<div
  {...stylex.props([
    styles.base,
    props.isHighlighted && styles.highlighted,
    isActive ? styles.active : styles.inactive,
  ])}
/>
```

:::info Inline conditional logic

It is recommended that you inline the conditional logic to apply your styles
directly with the `stylex.props()` calls for readability.

:::

When using styles conditionally, you can use ternary expressions, or the `&&`
operator. Remember that any pattern that would work while merging objects with
`Object.assign`, should work here too.

## Prop-based variants

A common styling pattern called "variants" lets you apply one of a list of
possible styles based on the value of the prop named `variant`.

StyleX supports this pattern no additional API.

First to define your variant styles, you can define a set of style with
`Style Names` that match your variant names.

```tsx
import * as stylex from '@stylexjs/stylex';

// Base Styles:
const styles = stylex.create({
  base: {
    /* ...base styles here... */
  },
});

const colorVariants = stylex.create({
  violet: {
    backgroundColor: {
      default: 'blueviolet',
      ':hover': 'darkviolet',
    },
    color: 'white',
  },
  gray: {
    backgroundColor: {
      default: 'gainsboro',
      ':hover': 'lightgray',
    },
  },
  // ... more variants here ...
});
```

And then you apply the styles by using your variant prop as a key on the
`colorVariants` object.

```tsx
function Button({color, ...props}) {
  return (
    <button {...props} {...stylex.props([styles.base, colorVariants[color]])} />
  );
}
```

As always, we try to not introduce any new concepts or APIs when existing object
patterns can be used.

## Composing styles across modules

When you define styles, you don’t have to use those styles in the same module.
You can also pass them like any other value across modules as props to a custom
component.

## Using styles from props

```tsx
<CustomComponent style={styles.base} />
```

:::warning

Don't use the `stylex.props` or `stylex` functions when passing styles to a
custom component.

```tsx
// NO!
<CustomComponent style={stylex.props([styles.base])} />
```

The `stylex.props` function should only be used directly on an HTML element.
Here, we used a prop named `style` on a custom component named
`CustomComponent`.

:::

Conditional styles just you would when setting styles on an HTML element. The
only difference is that instead of using the `stylex.props` function, we use an
Array literal instead:

```tsx
<CustomComponent style={[styles.base, styles.highlighted]} />;

<CustomComponent
  style={[styles.base, props.isHighlighted && styles.highlighted]}
/>;
```

:::info Prop names are arbitrary

The prop name `style` is an arbitrary name. You can choose your own prop names
for your codebase.

We recommend using `style` when sharing your components with
the community.

:::

Accepting custom `StyleX Styles` is as simple as accepting any other prop.

```tsx
import * as stylex from '@stylexjs/stylex';

// Local Styles
const styles = stylex.create({
  base: {
    /*...*/
  },
});

function CustomComponent({style}) {
  return <div {...stylex.props([styles.base, style])} />;
}
```

The `style` prop which is passed from another component (example above) may
either be a single object or an Array of multiple objects. Luckily, the
`stylex.props` function can handle nested Arrays of style objects and the code
above will _just work_.

In the code example above, the external styles in the `style` prop is passed
last to the `stylex.props` function. This means that any external styles will
override and win over any local styles defined in `styles.foo`. While this is
not a requirement of styles, we recommend that you follow this pattern for your
own custom components so that you can have predictable behavior when passing
styles to custom component.

There may be cases when you don't want to allow overriding certain local styles
in your custom component. In such cases, we recommend that you limit the styles
that can be passed into your component with Prop Types.

Not only can you accept StyleX style objects as props, the styles are also fully
type-safe as you can add type annotations (in Typescript or Flow) to define
exactly the styles you accept.

:::info

If you're not using Typescript (or Flow) in your codebase, you can pass styles
that should not be override-able after `style` to the `stylex()` or
`stylex.props()` function call.

```tsx
import * as stylex from '@stylexjs/stylex';

// Local Styles
const styles = stylex.create({
  base: {
    /*...*/
  },
  essential: {
    /*...*/
  },
});

function CustomComponent({style}) {
  return <div {...stylex.props([styles.base, style, styles.essential])} />;
}
```

:::

## “Unsetting” styles

Sometimes, instead of passing in your own override styles, you simply want to
remove styles that have already been applied by a component. CSS gives you a few
values to do so such as `initial`, `inherit`, `unset`, and `revert`.

You can use these values in StyleX too, but they result in their own atomic
className that is usually redundant. Instead, if you just want to remove StyleX
styles for a particular property you can set it's value to `null`.

Here is an example to remove the `color` style from a component:

```tsx
import * as stylex from '@stylexjs/stylex';

const styles = stylex.create({
  base: {
    color: null,
  },
});
```

`styles.base` would behave the same as if `color: inherit` was used in CSS, but
there will be no className for the `color` property applied at all.
