---
title: 'stylex.when.*'
---

A suite of APIs for creating descendant and sibling selectors. These let you
style an element based on the state of its ancestors, descendants, or siblings
in the DOM tree. You can observe pseudo-class states (`:hover`, `:focus`, etc.)
or attribute selectors (e.g., `[data-panel-state="open"]`) on an element that
has been marked with a marker class.

> Note: lookahead selectors (`stylex.when.siblingAfter`,
> `stylex.when.anySibling`, and `stylex.when.descendant`) rely on the CSS
> `:has()` selector, which does not yet have
> [wide browser support](https://caniuse.com/css-has).

## Using markers

To use descendant and sibling selectors, mark the ancestor, sibling, or
descendant node being observed by passing the `stylex.defaultMarker()` class
name.

```tsx
import * as stylex from '@stylexjs/stylex';

const styles = stylex.create({
  foo: {
    backgroundColor: {
      default: 'blue',
      [stylex.when.ancestor(':hover')]: 'red',
    },
  },
});

<div {...stylex.props(stylex.defaultMarker())}>
  <div {...stylex.props(styles.foo)}>Some content</div>
</div>;
```

## Available selectors

### `stylex.when.ancestor`

Style an element based on the state of an ancestor element in the DOM tree.

```ts
function ancestor(pseudoSelector: string, marker?: Marker): string;
```

```tsx
import * as stylex from '@stylexjs/stylex';

const styles = stylex.create({
  card: {
    transform: {
      default: 'translateX(0)',
      [stylex.when.ancestor(':hover')]: 'translateX(10px)',
    },
  },
});

<div {...stylex.props(stylex.defaultMarker())}>
  <div {...stylex.props(styles.card)}>Hover the parent to move me</div>
</div>;
```

### `stylex.when.descendant`

Style an element based on the state of a descendant element in the DOM tree.

```ts
function descendant(pseudoSelector: string, marker?: Marker): string;
```

```tsx
import * as stylex from '@stylexjs/stylex';

const styles = stylex.create({
  container: {
    borderColor: {
      default: 'gray',
      [stylex.when.descendant(':focus')]: 'blue',
    },
  },
});

<div {...stylex.props(styles.container)}>
  <input {...stylex.props(stylex.defaultMarker())} />
</div>;
```

### `stylex.when.anySibling`

Style an element based on the state of any sibling element (before or after).

```ts
function anySibling(pseudoSelector: string, marker?: Marker): string;
```

```tsx
import * as stylex from '@stylexjs/stylex';

const styles = stylex.create({
  tab: {
    opacity: {
      default: 1,
      [stylex.when.anySibling(':hover')]: 0.7,
    },
  },
});

<>
  <div {...stylex.props(styles.tab, stylex.defaultMarker())}>Tab 1</div>
  <div {...stylex.props(styles.tab, stylex.defaultMarker())}>Tab 2</div>
  <div {...stylex.props(styles.tab, stylex.defaultMarker())}>Tab 3</div>
</>;
```

### `stylex.when.siblingBefore`

Style an element based on the state of a preceding sibling element.

```ts
function siblingBefore(pseudoSelector: string, marker?: Marker): string;
```

```tsx
import * as stylex from '@stylexjs/stylex';

const styles = stylex.create({
  item: {
    backgroundColor: {
      default: 'white',
      [stylex.when.siblingBefore(':focus')]: 'lightblue',
    },
  },
});

<>
  <button {...stylex.props(stylex.defaultMarker())}>Focus me</button>
  <div {...stylex.props(styles.item)}>I change when the button is focused</div>
</>;
```

### `stylex.when.siblingAfter`

Style an element based on the state of a following sibling element.

```ts
function siblingAfter(pseudoSelector: string, marker?: Marker): string;
```

```tsx
import * as stylex from '@stylexjs/stylex';

const styles = stylex.create({
  label: {
    color: {
      default: 'black',
      [stylex.when.siblingAfter(':focus')]: 'blue',
    },
  },
});

<>
  <label {...stylex.props(styles.label)}>Name</label>
  <input {...stylex.props(stylex.defaultMarker())} />
</>;
```

## Using custom markers

Custom markers created with `stylex.defineMarker()` let you have multiple
independent sets of contextual selectors in the same component tree. For
example, a table cell could have different styling depending on whether
the cell itself is being hovered, or whether its row is being hovered:

```tsx
// markers.stylex.js
import * as stylex from "@stylexjs/stylex";
export const rowMarker = stylex.defineMarker();
export const cellMarker = stylex.defineMarker();

```
```tsx
import * as stylex from "@stylexjs/stylex";
import { cellMarker, rowMarker } from "./markers.stylex.js";

const styles = stylex.create({
  editButton: {
    visibility: {
      // Show button when row is hovered
      default: 'hidden',
      [stylex.when.ancestor(':hover', rowMarker)]: 'visible',
    },
    opacity: {
      // Dim the button unless the cell itself is hovered
      default: 0.4,
      [stylex.when.ancestor(':hover', cellMarker)]: 1,
    },
  },
});

function Row({ children }) {
  return <tr {...stylex.props(rowMarker)}>{children}</tr>;
}

function Cell({ children }) {
  return (<td {...stylex.props(cellMarker)}>{children}</td>);
}

function EditableContents({children}) {
  return (
    <>
      {children}
      <button {...stylex.props(styles.editButton)}>Edit</button>
    </>
  );
}

export default function App() {
  return (
    <table>
      <Row>
        <Cell><EditableContents>Daniel</EditableContents></Cell>
        <Cell>1234</Cell>
      </Row>
      <Row>
        <Cell><EditableContents>Test</EditableContents></Cell>
        <Cell>Two</Cell>
      </Row>
    </table>
  );
}

```

## Specificity ranking

`stylex.when.*` selectors have lower priority than regular pseudo-classes or
media queries. When multiple `stylex.when.*` selectors apply to the same
element, they are ordered by specificity:

1. `ancestor` (lowest specificity)
2. `descendant`
3. `anySibling`
4. `siblingBefore`
5. `siblingAfter` (highest specificity)
