---
title: 'processStylexRules'
---

`processStylexRules` is a function exported from `@stylexjs/babel-plugin` that takes
an array of CSS rules collected during babel transformation and generates the final
CSS output. This API is useful for building custom bundler integrations or improving
existing ones.

## Usage

```ts
import stylexBabelPlugin from '@stylexjs/babel-plugin';

// Rules collected from babel transformation metadata
const rules = [
  // ... metadata.stylex from babel transform results
];

const css = stylexBabelPlugin.processStylexRules(rules, {
  useLayers: false,
  enableLTRRTLComments: false,
});
```

## Function Signature

```ts
type Rule = [
  string,                                    // className hash
  { ltr: string; rtl?: null | string },      // CSS rule object
  number                                     // priority
];

function processStylexRules(
  rules: Array<Rule>,
  config?: boolean | {
    useLayers?: boolean;
    enableLTRRTLComments?: boolean;
    legacyDisableLayers?: boolean;
    useLegacyClassnamesSort?: boolean;
  }
): string;
```

## How it works

When StyleX compiles your JavaScript files, the babel plugin returns metadata
containing an array of CSS rule objects. You collect these rules from all files in
your project, then pass them to `processStylexRules` which:

1. De-duplicates the rules
2. Sorts them by priority
3. Resolves `stylex.defineConsts` references
4. Generates the final CSS string

## Configuration options

### `useLayers`

```ts
useLayers: boolean; // Default: false
```

When `true`, uses CSS `@layer` to group rules by priority level. This provides
native browser support for style priority ordering without specificity hacks.

Example output with `useLayers: true`:
```css
@layer priority1, priority2, priority3;

@layer priority2 {
  .margin-xymmreb { margin: 10px 20px }
}

@layer priority3 {
  .backgroundColor-xrkmrrc { background-color: red }
}
```

---

### `enableLTRRTLComments`

```ts
enableLTRRTLComments: boolean; // Default: false
```

When `true`, wraps LTR/RTL variants with comments instead of using attribute
selectors. Useful for post-processing with tools that can strip or swap comments
based on document direction.

Example output with `enableLTRRTLComments: true`:
```css
/* @ltr begin */.float-x1kmio9f { float: left }/* @ltr end */
/* @rtl begin */.float-x1kmio9f { float: right }/* @rtl end */
```

Example output with `enableLTRRTLComments: false` (default):
```css
html:not([dir='rtl']) .float-x1kmio9f { float: left }
html[dir='rtl'] .float-x1kmio9f { float: right }
```

---

### `legacyDisableLayers`

```ts
legacyDisableLayers: boolean; // Default: false
```

When `true`, disables the specificity polyfill (`:not(#\#)` selectors) that
StyleX uses when `useLayers` is `false`. Only use this if you have a custom
solution for handling style priority.

---

### `useLegacyClassnamesSort`

```ts
useLegacyClassnamesSort: boolean; // Default: false
```

When `true`, sorts rules alphabetically by className within each priority group.
When `false` (default), sorts by CSS property for more predictable output.

## Example: Custom Bundler Integration

```ts
import { transformAsync } from '@babel/core';
import stylexBabelPlugin from '@stylexjs/babel-plugin';

// Store rules from all files
const allRules = [];

// Transform each file
async function transformFile(code, filename) {
  const result = await transformAsync(code, {
    filename,
    plugins: [
      [stylexBabelPlugin, { /* your options */ }]
    ],
  });

  // Collect rules from metadata
  if (result.metadata?.stylex?.length > 0) {
    allRules.push(...result.metadata.stylex);
  }

  return result.code;
}

// After all files are processed, generate CSS
function generateCSS() {
  return stylexBabelPlugin.processStylexRules(allRules, {
    useLayers: true,
  });
}
```
