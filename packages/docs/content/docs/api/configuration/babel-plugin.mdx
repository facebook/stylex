---
title: "@stylexjs/babel-plugin"
---

## Configuration options

<TypeTable 
  type={{
    classNamePrefix: {
      description: 'Prefix to applied to every generated className.',
      type: 'string',
      default: '"x"'
    },
    debug: {
      description: 'Enable `data-style-src` props to help identify the source of the styles and className prefixes to identy style properties being applied.',
      type: 'boolean',
      default: 'false'
    },
    dev: {
      description: 'Enable runtime injection of styles. This may be useful during development but should be disabled in production.',
      type: 'boolean',
      default: 'false'
    },
    test: {
      description: 'Enable snapshot testing mode. It disable all classNames except dev classNames. This helps avoid testing churn with evolving styles.',
      type: 'boolean',
      default: 'false'
    },
    enableDebugClassNames: {
      description: 'Enable debug class names. It will change the generated classNames to have a prefix of the css property being applied.',
      type: 'boolean',
      default: 'value of `debug`'
    },
    enableDebugDataProp: {
      description: 'Enable `data-style-src` prop to help identify the source of the styles.',
      type: 'boolean',
      default: 'value of `debug`'
    },
    enableDevClassNames: {
      description: 'Enable dev class names that do nothing but help identify the source of the styles.',
      type: 'boolean',
      default: 'false'
    },
    enableFontSizePxToRem: {
      description: 'Enable conversion of font-size values in pixels to rem units. This is a best practive for a11y.',
      type: 'boolean',
      default: 'false'
    },
    enableMediaQueryOrder: {
      description: 'EXPERIMENTAL: Enable media query order enforcement. It will rewrite media queries at compile to enforce the specificity matches the order of styles in the source.',
      type: 'boolean',
      default: 'false'
    },
    
    styleResolution: {
      description: 'Strategy to use for merging styles.',
      type: '"application-order" | "property-specificity" | "legacy-expand-shorthands"',
      default: 'property-specificity',
    },
    aliases: {
      description: 'Aliases to project directories to absolute paths, making it easier to import modules.',
      type: '{ [key: string]: string | Array<string> }'
    },
    rewriteAliases: {
      description: 'Rewrite aliases to project directories to absolute paths. This is useful for setting up custom module aliases.',
      type: 'boolean',
      default: 'false'
    },
    importSources: {
      description: 'Override the package name where you can import stylex from. Used for setting up custom module aliases.',
      type: 'Array<string | { from: string, as: string }>',
      default: '["@stylexjs/stylex"]'
    },
    runtimeInjection: {
      description: 'Should StyleX generate code to inject styles at runtime? This may be useful during development but should be disabled in production.',
      type: 'boolean',
      default: 'the value of `dev`'
    },
    treeshakeCompensation: {
      description: 'Named imports of StyleX variables are unused after compilation. Some bundlers may remove them as dead code. Causing variables to be undefined. Enable this option to prevent that by adding an import with no specifier. (e.g. `import "./my-vars.stylex.js"`)',
      type: 'boolean',
      default: 'false'
    },
    unstable_moduleResolution: {
      description: 'Strategy to use for resolving variables defined with `defineVars`. This is required if you plan to use StyleX\'s theming APIs.',
      type: '{ type: "commonJS", rootDir?: string, themeFileExtension?: string } | ...',
      typeDescription:
        <code><pre>
          | {'{ type: "commonJS", rootDir?: string, themeFileExtension?: string }'}
          <br />
          | {'{ type: "haste", themeFileExtension?: string }'}
          <br />
          | {'{ type: "custom",\n    filePathResolver: (\n      importPath: string,\n      sourceFilePath: string,\n      aliases: ?{ [string]: Array<string> }\n    ) => string | void,\n    getCanonicalFilePath: (filePath: string) => string\n  }'}
          </pre>
        </code>
    },
    enableLegacyValueFlipping: {
      description: 'Enable legacy value flipping. It will flip the value of the css property if the value is a string and contains `-`.',
      type: 'boolean',
      default: 'false',
      deprecated: true
    },
    enableLogicalStylesPolyfill: {
      description: 'Enable logical styles polyfill. It will rewrite logical styles at compile to use the logical properties.',
      type: 'boolean',
      default: 'false',
      deprecated: true
    },
  }}
/>


### `aliases`

```ts
aliases: {[key: string]: string | Array<string>} // Default: undefined
```

`aliases` option allows you to alias project directories to absolute paths, making it easier to import modules.

Example: `'@/components/*': [path.join(__dirname, './src/components/*')]`

---

### `classNamePrefix`

```ts
classNamePrefix: string // Default: 'x'
```

Prefix to applied to every generated className.

---

### `debug`

```ts
debug: boolean // Default: false
```

When `true`, StyleX will use debug class names and insert `data-style-src` props to help identify the source of the styles.

---

### `dev`

```ts
dev: boolean // Default: false
```

When `true`, StyleX will insert function calls to inject the CSS rules at runtime, making it possible to use StyleX without setting up CSS file extraction.

---

### `importSources`

```ts
importSources: Array<string | { from: string, as: string }> // Default: ['@stylexjs/stylex']
```

Override the package name where you can import stylex from. Used for setting up custom module aliases.

Example: `importSources: ['stylex', { from: '@acme/ui', as: 'css' }]`

---

### `runtimeInjection`

```ts
runtimeInjection: boolean // Default: false
```

Should StyleX generate code to inject styles at runtime?
This may be useful during development but should be disabled in production.

---

### `styleResolution`

```ts
styleResolution: // Default: 'property-specificity'
  | 'application-order'
  | 'property-specificity'
```

Strategy to use for merging styles.
- **application-order**: The last style applied wins. Consistent with how
  inline styles work on the web.
- **property-specificity**: More specific styles will win over less specific
  styles. Consistent with React Native. (`margin-top` wins over `margin`)

---

### `test`

```ts
test: boolean // Default: false
```

When `true`, StyleX will only output debug classNames identifying the
source of the styles.

It will *not* generate any styles or functional classNames.
This can be useful for snapshot testing.

---

### `treeshakeCompensation`

```ts
treeshakeCompensation: boolean // Default: false
```

Named imports of StyleX variables are unused after compilation.
Some bundlers may remove them as dead code. Causing variables to be undefined.
Enable this option to prevent that by adding an import with no specifier.
(e.g. `import './my-vars.stylex.js'`)

---

### `unstable_moduleResolution`

```ts
unstable_moduleResolution: // Default: undefined
  | {
      // The module system to be used.
      // Use this value when using `ESModules`.
      type: 'commonJS',
      // The absolute path to the root directory of your project.
      // Only used as a fallback
      rootDir?: string,
      // Override `.stylex.js` with your own extension.
      themeFileExtension?: string,
    }
  | {
      // Use this when using the Haste module system
      // Where all files are imported by filename rather
      // than relative paths and all filenames must be unique.
      type: 'haste',
      // Override `.stylex.js` with your own extension.
      themeFileExtension?: string,
    }
```

Strategy to use for resolving variables defined with `defineVars`.
This is required if you plan to use StyleX's theming APIs.

**NOTE**: While theming APIs are stable, the shape of this configuration option
may change in the future.
