/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow strict
 */

'use strict';

import type { CSSProperties } from './StyleXCSSTypes';
import type { StyleXClassNameFor, StyleXVar } from './StyleXOpaqueTypes';
import type { CSSType } from './VarTypes';

export type { StyleXClassNameFor, StyleXVar } from './StyleXOpaqueTypes';

// Using an opaque type to declare ClassNames generated by stylex.
export type StyleXClassNameForValue<+V> = StyleXClassNameFor<mixed, V>;
export type StyleXClassNameForKey<+K> = StyleXClassNameFor<K, mixed>;
export type StyleXClassName = StyleXClassNameFor<mixed, mixed>;

// Type for arbitrarily nested Array.
export type StyleXArray<+T> = T | $ReadOnlyArray<StyleXArray<T>>;

type CSSPropertiesWithExtras = $ReadOnly<{
  ...CSSProperties,
  '::before'?: CSSProperties,
  '::after'?: CSSProperties,
  '::backdrop'?: CSSProperties,
  '::cue'?: CSSProperties,
  '::cue-region'?: CSSProperties,
  '::first-letter'?: CSSProperties,
  '::first-line'?: CSSProperties,
  '::file-selector-button'?: CSSProperties,
  '::grammar-error'?: CSSProperties,
  '::marker'?: CSSProperties,
  '::placeholder'?: CSSProperties,
  '::selection'?: CSSProperties,
  '::spelling-error'?: CSSProperties,
  '::target-text'?: CSSProperties,
  '::-webkit-scrollbar'?: CSSProperties,
  // webkit styles used for Search in Safari
  '::-webkit-search-decoration'?: CSSProperties,
  '::-webkit-search-cancel-button'?: CSSProperties,
  '::-webkit-search-results-button'?: CSSProperties,
  '::-webkit-search-results-decoration'?: CSSProperties,
}>;

export type NestedCSSPropTypes = $ReadOnly<{
  [Key in keyof CSSPropertiesWithExtras]?: StyleXClassNameForKey<Key>,
}>;

export type StyleXSingleStyle = false | ?NestedCSSPropTypes;
export type XStyle<+T = NestedCSSPropTypes> = StyleXArray<
  false | ?$ReadOnly<{ ...T, $$css: true }>,
>;

export type XStyleWithout<+T: { +[_K in keyof NestedCSSPropTypes]?: mixed }> =
  XStyle<$ReadOnly<Omit<NestedCSSPropTypes, $Keys<T>>>>;

export type Keyframes = $ReadOnly<{ [name: string]: CSSProperties, ... }>;

export type PositionTry = $ReadOnly<{
  // Anchor Positioning Properties
  positionAnchor?: CSSProperties['positionAnchor'],
  positionArea?: CSSProperties['positionArea'],
  // inset Properties
  top?: CSSProperties['top'],
  right?: CSSProperties['right'],
  bottom?: CSSProperties['bottom'],
  left?: CSSProperties['left'],
  inset?: CSSProperties['inset'],
  insetBlock?: CSSProperties['insetBlock'],
  insetBlockEnd?: CSSProperties['insetBlockEnd'],
  insetBlockStart?: CSSProperties['insetBlockStart'],
  insetInline?: CSSProperties['insetInline'],
  insetInlineEnd?: CSSProperties['insetInlineEnd'],
  insetInlineStart?: CSSProperties['insetInlineStart'],
  // margin Properties
  margin?: CSSProperties['margin'],
  marginBlock?: CSSProperties['marginBlock'],
  marginBlockEnd?: CSSProperties['marginBlockEnd'],
  marginBlockStart?: CSSProperties['marginBlockStart'],
  marginInline?: CSSProperties['marginInline'],
  marginInlineEnd?: CSSProperties['marginInlineEnd'],
  marginInlineStart?: CSSProperties['marginInlineStart'],
  marginTop?: CSSProperties['marginTop'],
  marginBottom?: CSSProperties['marginBottom'],
  marginLeft?: CSSProperties['marginLeft'],
  marginRight?: CSSProperties['marginRight'],
  // size properties
  width?: CSSProperties['width'],
  height?: CSSProperties['height'],
  minWidth?: CSSProperties['minWidth'],
  minHeight?: CSSProperties['minHeight'],
  maxWidth?: CSSProperties['maxWidth'],
  maxHeight?: CSSProperties['maxHeight'],
  blockSize?: CSSProperties['blockSize'],
  inlineSize?: CSSProperties['inlineSize'],
  minBlockSize?: CSSProperties['minBlockSize'],
  minInlineSize?: CSSProperties['minInlineSize'],
  maxBlockSize?: CSSProperties['maxBlockSize'],
  maxInlineSize?: CSSProperties['maxInlineSize'],
  // self alignment properties
  alignSelf?: CSSProperties['alignSelf'],
  justifySelf?: CSSProperties['justifySelf'],
  placeSelf?: CSSProperties['placeSelf'],
}>;

export type ViewTransitionClass = $ReadOnly<{
  group?: CSSProperties,
  imagePair?: CSSProperties,
  old?: CSSProperties,
  new?: CSSProperties,
}>;

export type LegacyThemeStyles = $ReadOnly<{
  [constantName: string]: string,
  ...
}>;

type ComplexStyleValueType<+T> =
  T extends StyleXVar<infer U>
    ? U extends CSSType<infer V>
      ? V
      : U
    : T extends string | number | null
      ? T
      : T extends $ReadOnlyArray<infer U>
        ? ComplexStyleValueType<U>
        : T extends { +default: infer A, +[string]: infer B }
          ? ComplexStyleValueType<A> | ComplexStyleValueType<B>
          : $ReadOnly<T>;

type _MapNamespace<+CSS: { +[string]: mixed }> = $ReadOnly<{
  [Key in keyof CSS]: StyleXClassNameFor<Key, ComplexStyleValueType<CSS[Key]>>,
}>;
export type MapNamespace<+CSS: { +[string]: mixed }> = $ReadOnly<{
  ..._MapNamespace<CSS>,
  $$css: true,
}>;
export type MapNamespaces<+S: { +[string]: mixed }> = $ReadOnly<{
  [Key in keyof S]: S[Key] extends (...args: infer Args) => infer Obj
    ? (...args: Args) => $ReadOnly<[MapNamespace<Obj>, InlineStyles]>
    : MapNamespace<S[Key]>,
}>;
export type StyleX$Create = <const S: { +[string]: { ... } }>(
  styles: S,
) => MapNamespaces<S>;

export type CompiledStyles = $ReadOnly<{
  $$css: true,
  [key: string]: StyleXClassName,
}>;
export type InlineStyles = $ReadOnly<{
  $$css?: void,
  [key: string]: string,
}>;

type _GenStylePropType<+CSS: { +[string]: mixed }> = $ReadOnly<{
  [Key in keyof CSS]: CSS[Key] extends { +[string]: mixed }
    ? StyleXClassNameFor<Key, $ReadOnly<CSS[Key]>>
    : StyleXClassNameFor<Key, CSS[Key]>,
}>;
type GenStylePropType<+CSS: { +[string]: mixed }> = $ReadOnly<{
  ..._GenStylePropType<CSS>,
  $$css: true,
}>;

// Replace `XStyle` with this.
export type StaticStyles<+CSS: { +[string]: mixed } = CSSPropertiesWithExtras> =
  StyleXArray<false | ?GenStylePropType<$ReadOnly<CSS>>>;

export type StaticStylesWithout<+CSS: { +[string]: mixed }> = StaticStyles<
  Omit<CSSPropertiesWithExtras, $Keys<CSS>>,
>;

export type StyleXStyles<+CSS: { +[string]: mixed } = CSSPropertiesWithExtras> =
  StyleXArray<
    | ?false
    | GenStylePropType<$ReadOnly<CSS>>
    | $ReadOnly<[GenStylePropType<$ReadOnly<CSS>>, InlineStyles]>,
  >;

export type StyleXStylesWithout<+CSS: { +[string]: mixed }> = StyleXStyles<
  Omit<CSSPropertiesWithExtras, $Keys<CSS>>,
>;

export type VarGroup<+Tokens: { +[string]: mixed }, +_ID: string = string> = {
  +[Key in keyof Tokens]: StyleXVar<Tokens[Key]>,
};

export type TokensFromVarGroup<+T: VarGroup<{ +[string]: mixed }>> = $ReadOnly<{
  [Key in keyof T]: UnwrapVar<T[Key]>,
}>;

type IDFromVarGroup<+T: VarGroup<{ +[string]: mixed }>> =
  T extends VarGroup<{ +[string]: mixed }, infer ID> ? ID : empty;

type NestedVarObject<+T> =
  | T
  | $ReadOnly<{
      default: NestedVarObject<T>,
      [string]: NestedVarObject<T>,
    }>;

type TTokens = $ReadOnly<{
  [string]:
    | NestedVarObject<null | string | number>
    | StyleXVar<null | string | number>
    | CSSType<null | string | number>,
}>;

type UnwrapVar<+T> = T extends StyleXVar<infer U> ? U : T;
export type FlattenTokens<+T: TTokens> = {
  +[Key in keyof T]: T[Key] extends CSSType<string | number>
    ? UnwrapVar<T[Key]>
    : T[Key] extends { +default: infer X, +[string]: infer Y }
      ? UnwrapVar<X | Y>
      : UnwrapVar<T[Key]>,
};

export type StyleX$DefineVars = <DefaultTokens: TTokens, ID: string = string>(
  tokens: DefaultTokens,
) => VarGroup<FlattenTokens<DefaultTokens>, ID>;

export type StyleX$DefineConsts = <
  const DefaultTokens: { +[string]: number | string },
>(
  tokens: DefaultTokens,
) => DefaultTokens;

// opaque type ThemeKey<+_VG: VarGroup<{ +[string]: mixed }>>: string = string;
export opaque type Theme<
  +T: VarGroup<{ +[string]: mixed }, string>,
  +_Tag: string = string,
>: $ReadOnly<{
  $$css: true,
  theme: StyleXClassNameFor<'theme', IDFromVarGroup<T>>,
}> = $ReadOnly<{
  $$css: true,
  theme: StyleXClassNameFor<'theme', IDFromVarGroup<T>>,
}>;

export type OverridesForTokenType<+Config: { +[string]: mixed }> = {
  [Key in keyof Config]?: NestedVarObject<Config[Key]>,
};

export type StyleX$CreateTheme = <
  BaseTokens: VarGroup<{ +[string]: mixed }>,
  ID: string = string,
>(
  baseTokens: BaseTokens,
  overrides: OverridesForTokenType<TokensFromVarGroup<BaseTokens>>,
) => Theme<BaseTokens, ID>;

export type StyleX$DefineMarker = () => MapNamespace<{
  +marker: 'custom-marker',
}>;

export type StyleX$When = {
  ancestor: (
    _pseudo?: StringPrefix<':'>,
    _customMarker?: MapNamespace<{ +marker: 'custom-marker' }>,
  ) => ':where-ancestor',
  descendant: (
    _pseudo?: StringPrefix<':'>,
    _customMarker?: MapNamespace<{ +marker: 'custom-marker' }>,
  ) => ':where-descendant',
  siblingBefore: (
    _pseudo?: StringPrefix<':'>,
    _customMarker?: MapNamespace<{ +marker: 'custom-marker' }>,
  ) => ':where-sibling-before',
  siblingAfter: (
    _pseudo?: StringPrefix<':'>,
    _customMarker?: MapNamespace<{ +marker: 'custom-marker' }>,
  ) => ':where-sibling-after',
  anySibling: (
    _pseudo?: StringPrefix<':'>,
    _customMarker?: MapNamespace<{ +marker: 'custom-marker' }>,
  ) => ':where-any-sibling',
};
