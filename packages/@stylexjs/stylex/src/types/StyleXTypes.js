/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @flow strict
 */

'use strict';

import type { CSSProperties } from './StyleXCSSTypes';
import type { StyleXClassNameFor, StyleXVar } from './StyleXOpaqueTypes';
import type { CSSType } from './VarTypes';

export type { StyleXClassNameFor, StyleXVar } from './StyleXOpaqueTypes';

// Using an opaque type to declare ClassNames generated by stylex.
export type StyleXClassNameForValue<+V> = StyleXClassNameFor<unknown, V>;
export type StyleXClassNameForKey<+K> = StyleXClassNameFor<K, unknown>;
export type StyleXClassName = StyleXClassNameFor<unknown, unknown>;

// Type for arbitrarily nested Array.
export type StyleXArray<+T> = T | ReadonlyArray<StyleXArray<T>>;

type CSSPropertiesWithExtras = Readonly<{
  ...CSSProperties,
  '::before'?: CSSProperties,
  '::after'?: CSSProperties,
  '::backdrop'?: CSSProperties,
  '::cue'?: CSSProperties,
  '::cue-region'?: CSSProperties,
  '::first-letter'?: CSSProperties,
  '::first-line'?: CSSProperties,
  '::file-selector-button'?: CSSProperties,
  '::grammar-error'?: CSSProperties,
  '::marker'?: CSSProperties,
  '::placeholder'?: CSSProperties,
  '::selection'?: CSSProperties,
  '::spelling-error'?: CSSProperties,
  '::target-text'?: CSSProperties,
  '::-webkit-scrollbar'?: CSSProperties,
  // webkit styles used for Search in Safari
  '::-webkit-search-decoration'?: CSSProperties,
  '::-webkit-search-cancel-button'?: CSSProperties,
  '::-webkit-search-results-button'?: CSSProperties,
  '::-webkit-search-results-decoration'?: CSSProperties,
}>;

export type NestedCSSPropTypes = Readonly<{
  [Key in keyof CSSPropertiesWithExtras]?: StyleXClassNameForKey<Key>,
}>;

export type StyleXSingleStyle = false | ?NestedCSSPropTypes;
export type XStyle<+T = NestedCSSPropTypes> = StyleXArray<
  false | ?Readonly<{ ...T, $$css: true }>,
>;

export type XStyleWithout<+T: { +[_K in keyof NestedCSSPropTypes]?: unknown }> =
  XStyle<Readonly<Omit<NestedCSSPropTypes, keyof T>>>;

export type Keyframes = Readonly<{ [name: string]: CSSProperties, ... }>;

export type PositionTry = Readonly<{
  // Anchor Positioning Properties
  positionAnchor?: CSSProperties['positionAnchor'],
  positionArea?: CSSProperties['positionArea'],
  // inset Properties
  top?: CSSProperties['top'],
  right?: CSSProperties['right'],
  bottom?: CSSProperties['bottom'],
  left?: CSSProperties['left'],
  inset?: CSSProperties['inset'],
  insetBlock?: CSSProperties['insetBlock'],
  insetBlockEnd?: CSSProperties['insetBlockEnd'],
  insetBlockStart?: CSSProperties['insetBlockStart'],
  insetInline?: CSSProperties['insetInline'],
  insetInlineEnd?: CSSProperties['insetInlineEnd'],
  insetInlineStart?: CSSProperties['insetInlineStart'],
  // margin Properties
  margin?: CSSProperties['margin'],
  marginBlock?: CSSProperties['marginBlock'],
  marginBlockEnd?: CSSProperties['marginBlockEnd'],
  marginBlockStart?: CSSProperties['marginBlockStart'],
  marginInline?: CSSProperties['marginInline'],
  marginInlineEnd?: CSSProperties['marginInlineEnd'],
  marginInlineStart?: CSSProperties['marginInlineStart'],
  marginTop?: CSSProperties['marginTop'],
  marginBottom?: CSSProperties['marginBottom'],
  marginLeft?: CSSProperties['marginLeft'],
  marginRight?: CSSProperties['marginRight'],
  // size properties
  width?: CSSProperties['width'],
  height?: CSSProperties['height'],
  minWidth?: CSSProperties['minWidth'],
  minHeight?: CSSProperties['minHeight'],
  maxWidth?: CSSProperties['maxWidth'],
  maxHeight?: CSSProperties['maxHeight'],
  blockSize?: CSSProperties['blockSize'],
  inlineSize?: CSSProperties['inlineSize'],
  minBlockSize?: CSSProperties['minBlockSize'],
  minInlineSize?: CSSProperties['minInlineSize'],
  maxBlockSize?: CSSProperties['maxBlockSize'],
  maxInlineSize?: CSSProperties['maxInlineSize'],
  // self alignment properties
  alignSelf?: CSSProperties['alignSelf'],
  justifySelf?: CSSProperties['justifySelf'],
  placeSelf?: CSSProperties['placeSelf'],
}>;

export type ViewTransitionClass = Readonly<{
  group?: CSSProperties,
  imagePair?: CSSProperties,
  old?: CSSProperties,
  new?: CSSProperties,
}>;

export type LegacyThemeStyles = Readonly<{
  [constantName: string]: string,
  ...
}>;

type ComplexStyleValueType<+T> =
  T extends StyleXVar<infer U>
    ? U extends CSSType<infer V>
      ? V
      : U
    : T extends string | number | null
      ? T
      : T extends ReadonlyArray<infer U>
        ? ComplexStyleValueType<U>
        : T extends { +default: infer A, +[string]: infer B }
          ? ComplexStyleValueType<A> | ComplexStyleValueType<B>
          : Readonly<T>;

type _MapNamespace<+CSS: { +[string]: unknown }> = Readonly<{
  [Key in keyof CSS]: StyleXClassNameFor<Key, ComplexStyleValueType<CSS[Key]>>,
}>;
export type MapNamespace<+CSS: { +[string]: unknown }> = Readonly<{
  ..._MapNamespace<CSS>,
  $$css: true,
}>;
export type MapNamespaces<+S: { +[string]: unknown }> = Readonly<{
  [Key in keyof S]: S[Key] extends (...args: infer Args) => infer Obj
    ? (...args: Args) => Readonly<[MapNamespace<Obj>, InlineStyles]>
    : MapNamespace<S[Key]>,
}>;
export type StyleX$Create = <const S: { +[string]: { ... } }>(
  styles: S,
) => MapNamespaces<S>;

export type CompiledStyles = Readonly<{
  $$css: true,
  [key: string]: StyleXClassName,
}>;
export type InlineStyles = Readonly<{
  $$css?: void,
  [key: string]: string,
}>;

type _GenStylePropType<+CSS: { +[string]: unknown }> = Readonly<{
  [Key in keyof CSS]: CSS[Key] extends { +[string]: unknown }
    ? StyleXClassNameFor<Key, Readonly<CSS[Key]>>
    : StyleXClassNameFor<Key, CSS[Key]>,
}>;
type GenStylePropType<+CSS: { +[string]: unknown }> = Readonly<{
  ..._GenStylePropType<CSS>,
  $$css: true,
}>;

// Replace `XStyle` with this.
export type StaticStyles<
  +CSS: { +[string]: unknown } = CSSPropertiesWithExtras,
> = StyleXArray<false | ?GenStylePropType<Readonly<CSS>>>;

export type StaticStylesWithout<+CSS: { +[string]: unknown }> = StaticStyles<
  Omit<CSSPropertiesWithExtras, keyof CSS>,
>;

export type StyleXStyles<
  +CSS: { +[string]: unknown } = CSSPropertiesWithExtras,
> = StyleXArray<
  | ?false
  | GenStylePropType<Readonly<CSS>>
  | Readonly<[GenStylePropType<Readonly<CSS>>, InlineStyles]>,
>;

export type StyleXStylesWithout<+CSS: { +[string]: unknown }> = StyleXStyles<
  Omit<CSSPropertiesWithExtras, keyof CSS>,
>;

export type VarGroup<+Tokens: { +[string]: unknown }, +_ID: string = string> = {
  +[Key in keyof Tokens]: StyleXVar<Tokens[Key]>,
};

export type TokensFromVarGroup<+T: VarGroup<{ +[string]: unknown }>> =
  Readonly<{
    [Key in keyof T]: UnwrapVar<T[Key]>,
  }>;

type IDFromVarGroup<+T: VarGroup<{ +[string]: unknown }>> =
  T extends VarGroup<{ +[string]: unknown }, infer ID> ? ID : empty;

type NestedVarObject<+T> =
  | T
  | Readonly<{
      default: NestedVarObject<T>,
      [string]: NestedVarObject<T>,
    }>;

type TTokens = Readonly<{
  [string]:
    | NestedVarObject<null | string | number>
    | StyleXVar<null | string | number>
    | CSSType<null | string | number>,
}>;

type UnwrapVar<+T> = T extends StyleXVar<infer U> ? U : T;
export type FlattenTokens<+T: TTokens> = {
  +[Key in keyof T]: T[Key] extends CSSType<string | number>
    ? UnwrapVar<T[Key]>
    : T[Key] extends { +default: infer X, +[string]: infer Y }
      ? UnwrapVar<X | Y>
      : UnwrapVar<T[Key]>,
};

export type StyleX$DefineVars = <DefaultTokens: TTokens, ID: string = string>(
  tokens: DefaultTokens,
) => VarGroup<FlattenTokens<DefaultTokens>, ID>;

export type StyleX$DefineConsts = <
  const DefaultTokens: { +[string]: number | string },
>(
  tokens: DefaultTokens,
) => DefaultTokens;

// opaque type ThemeKey<+_VG: VarGroup<{ +[string]: unknown }>>: string = string;
export opaque type Theme<
  +T: VarGroup<{ +[string]: unknown }, string>,
  +_Tag: string = string,
>: Readonly<{
  $$css: true,
  theme: StyleXClassNameFor<'theme', IDFromVarGroup<T>>,
}> = Readonly<{
  $$css: true,
  theme: StyleXClassNameFor<'theme', IDFromVarGroup<T>>,
}>;

export type OverridesForTokenType<+Config: { +[string]: unknown }> = {
  [Key in keyof Config]?: NestedVarObject<Config[Key]>,
};

export type StyleX$CreateTheme = <
  BaseTokens: VarGroup<{ +[string]: unknown }>,
  ID: string = string,
>(
  baseTokens: BaseTokens,
  overrides: OverridesForTokenType<TokensFromVarGroup<BaseTokens>>,
) => Theme<BaseTokens, ID>;

export type StyleX$DefineMarker = () => MapNamespace<{
  +marker: 'custom-marker',
}>;

export type StyleX$When = {
  ancestor: (
    _pseudo?: StringPrefix<':'> | StringPrefix<'['>,
    _customMarker?: MapNamespace<{ +marker: 'custom-marker' }>,
  ) => ':where-ancestor',
  descendant: (
    _pseudo?: StringPrefix<':'> | StringPrefix<'['>,
    _customMarker?: MapNamespace<{ +marker: 'custom-marker' }>,
  ) => ':where-descendant',
  siblingBefore: (
    _pseudo?: StringPrefix<':'> | StringPrefix<'['>,
    _customMarker?: MapNamespace<{ +marker: 'custom-marker' }>,
  ) => ':where-sibling-before',
  siblingAfter: (
    _pseudo?: StringPrefix<':'> | StringPrefix<'['>,
    _customMarker?: MapNamespace<{ +marker: 'custom-marker' }>,
  ) => ':where-sibling-after',
  anySibling: (
    _pseudo?: StringPrefix<':'> | StringPrefix<'['>,
    _customMarker?: MapNamespace<{ +marker: 'custom-marker' }>,
  ) => ':where-any-sibling',
};
