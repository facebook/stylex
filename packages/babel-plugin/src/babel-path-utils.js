/**
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

export function isAnyTypeAnnotation(path, props) {
  return path.isAnyTypeAnnotation(props);
}
export function isArrayExpression(path, props) {
  return path.isArrayExpression(props);
}
export function isArrayPattern(path, props) {
  return path.isArrayPattern(props);
}
export function isArrayTypeAnnotation(path, props) {
  return path.isArrayTypeAnnotation(props);
}
export function isArrowFunctionExpression(path, props) {
  return path.isArrowFunctionExpression(props);
}
export function isAssignmentExpression(path, props) {
  return path.isAssignmentExpression(props);
}
export function isAssignmentPattern(path, props) {
  return path.isAssignmentPattern(props);
}
export function isAwaitExpression(path, props) {
  return path.isAwaitExpression(props);
}
export function isBigIntLiteral(path, props) {
  return path.isBigIntLiteral(props);
}
export function isBinary(path, props) {
  return path.isBinary(props);
}
export function isBinaryExpression(path, props) {
  return path.isBinaryExpression(props);
}
export function isBindExpression(path, props) {
  return path.isBindExpression(props);
}
export function isBlock(path, props) {
  return path.isBlock(props);
}
export function isBlockParent(path, props) {
  return path.isBlockParent(props);
}
export function isBlockStatement(path, props) {
  return path.isBlockStatement(props);
}
export function isBooleanLiteral(path, props) {
  return path.isBooleanLiteral(props);
}
export function isBooleanLiteralTypeAnnotation(path, props) {
  return path.isBooleanLiteralTypeAnnotation(props);
}
export function isBooleanTypeAnnotation(path, props) {
  return path.isBooleanTypeAnnotation(props);
}
export function isBreakStatement(path, props) {
  return path.isBreakStatement(props);
}
export function isCallExpression(path, props) {
  return path.isCallExpression(props);
}
export function isCatchClause(path, props) {
  return path.isCatchClause(props);
}
export function isClass(path, props) {
  return path.isClass(props);
}
export function isClassBody(path, props) {
  return path.isClassBody(props);
}
export function isClassDeclaration(path, props) {
  return path.isClassDeclaration(props);
}
export function isClassExpression(path, props) {
  return path.isClassExpression(props);
}
export function isClassImplements(path, props) {
  return path.isClassImplements(props);
}
export function isClassMethod(path, props) {
  return path.isClassMethod(props);
}
export function isClassPrivateMethod(path, props) {
  return path.isClassPrivateMethod(props);
}
export function isClassPrivateProperty(path, props) {
  return path.isClassPrivateProperty(props);
}
export function isClassProperty(path, props) {
  return path.isClassProperty(props);
}
export function isCompletionStatement(path, props) {
  return path.isCompletionStatement(props);
}
export function isConditional(path, props) {
  return path.isConditional(props);
}
export function isConditionalExpression(path, props) {
  return path.isConditionalExpression(props);
}
export function isContinueStatement(path, props) {
  return path.isContinueStatement(props);
}
export function isDebuggerStatement(path, props) {
  return path.isDebuggerStatement(props);
}
export function isDeclaration(path, props) {
  return path.isDeclaration(props);
}
export function isDeclareClass(path, props) {
  return path.isDeclareClass(props);
}
export function isDeclareExportAllDeclaration(path, props) {
  return path.isDeclareExportAllDeclaration(props);
}
export function isDeclareExportDeclaration(path, props) {
  return path.isDeclareExportDeclaration(props);
}
export function isDeclareFunction(path, props) {
  return path.isDeclareFunction(props);
}
export function isDeclareInterface(path, props) {
  return path.isDeclareInterface(props);
}
export function isDeclareModule(path, props) {
  return path.isDeclareModule(props);
}
export function isDeclareModuleExports(path, props) {
  return path.isDeclareModuleExports(props);
}
export function isDeclareOpaqueType(path, props) {
  return path.isDeclareOpaqueType(props);
}
export function isDeclareTypeAlias(path, props) {
  return path.isDeclareTypeAlias(props);
}
export function isDeclareVariable(path, props) {
  return path.isDeclareVariable(props);
}
export function isDeclaredPredicate(path, props) {
  return path.isDeclaredPredicate(props);
}
export function isDecorator(path, props) {
  return path.isDecorator(props);
}
export function isDirective(path, props) {
  return path.isDirective(props);
}
export function isDirectiveLiteral(path, props) {
  return path.isDirectiveLiteral(props);
}
export function isDoExpression(path, props) {
  return path.isDoExpression(props);
}
export function isDoWhileStatement(path, props) {
  return path.isDoWhileStatement(props);
}
export function isEmptyStatement(path, props) {
  return path.isEmptyStatement(props);
}
export function isEmptyTypeAnnotation(path, props) {
  return path.isEmptyTypeAnnotation(props);
}
export function isExistsTypeAnnotation(path, props) {
  return path.isExistsTypeAnnotation(props);
}
export function isExportAllDeclaration(path, props) {
  return path.isExportAllDeclaration(props);
}
export function isExportDeclaration(path, props) {
  return path.isExportDeclaration(props);
}
export function isExportDefaultDeclaration(path, props) {
  return path.isExportDefaultDeclaration(props);
}
export function isExportDefaultSpecifier(path, props) {
  return path.isExportDefaultSpecifier(props);
}
export function isExportNamedDeclaration(path, props) {
  return path.isExportNamedDeclaration(props);
}
export function isExportNamespaceSpecifier(path, props) {
  return path.isExportNamespaceSpecifier(props);
}
export function isExportSpecifier(path, props) {
  return path.isExportSpecifier(props);
}
export function isExpression(path, props) {
  return path.isExpression(props);
}
export function isExpressionStatement(path, props) {
  return path.isExpressionStatement(props);
}
export function isExpressionWrapper(path, props) {
  return path.isExpressionWrapper(props);
}
export function isFile(path, props) {
  return path.isFile(props);
}
export function isFlow(path, props) {
  return path.isFlow(props);
}
export function isFlowBaseAnnotation(path, props) {
  return path.isFlowBaseAnnotation(props);
}
export function isFlowDeclaration(path, props) {
  return path.isFlowDeclaration(props);
}
export function isFlowPredicate(path, props) {
  return path.isFlowPredicate(props);
}
export function isFlowType(path, props) {
  return path.isFlowType(props);
}
export function isFor(path, props) {
  return path.isFor(props);
}
export function isForInStatement(path, props) {
  return path.isForInStatement(props);
}
export function isForOfStatement(path, props) {
  return path.isForOfStatement(props);
}
export function isForStatement(path, props) {
  return path.isForStatement(props);
}
export function isForXStatement(path, props) {
  return path.isForXStatement(props);
}
export function isFunction(path, props) {
  return path.isFunction(props);
}
export function isFunctionDeclaration(path, props) {
  return path.isFunctionDeclaration(props);
}
export function isFunctionExpression(path, props) {
  return path.isFunctionExpression(props);
}
export function isFunctionParent(path, props) {
  return path.isFunctionParent(props);
}
export function isFunctionTypeAnnotation(path, props) {
  return path.isFunctionTypeAnnotation(props);
}
export function isFunctionTypeParam(path, props) {
  return path.isFunctionTypeParam(props);
}
export function isGenericTypeAnnotation(path, props) {
  return path.isGenericTypeAnnotation(props);
}
export function isIdentifier(path, props) {
  return path.isIdentifier(props);
}
export function isIfStatement(path, props) {
  return path.isIfStatement(props);
}
export function isImmutable(path, props) {
  return path.isImmutable(props);
}
export function isImport(path, props) {
  return path.isImport(props);
}
export function isImportDeclaration(path, props) {
  return path.isImportDeclaration(props);
}
export function isImportDefaultSpecifier(path, props) {
  return path.isImportDefaultSpecifier(props);
}
export function isImportNamespaceSpecifier(path, props) {
  return path.isImportNamespaceSpecifier(props);
}
export function isImportSpecifier(path, props) {
  return path.isImportSpecifier(props);
}
export function isInferredPredicate(path, props) {
  return path.isInferredPredicate(props);
}
export function isInterfaceDeclaration(path, props) {
  return path.isInterfaceDeclaration(props);
}
export function isInterfaceExtends(path, props) {
  return path.isInterfaceExtends(props);
}
export function isInterfaceTypeAnnotation(path, props) {
  return path.isInterfaceTypeAnnotation(props);
}
export function isInterpreterDirective(path, props) {
  return path.isInterpreterDirective(props);
}
export function isIntersectionTypeAnnotation(path, props) {
  return path.isIntersectionTypeAnnotation(props);
}
export function isJSX(path, props) {
  return path.isJSX(props);
}
export function isJSXAttribute(path, props) {
  return path.isJSXAttribute(props);
}
export function isJSXClosingElement(path, props) {
  return path.isJSXClosingElement(props);
}
export function isJSXClosingFragment(path, props) {
  return path.isJSXClosingFragment(props);
}
export function isJSXElement(path, props) {
  return path.isJSXElement(props);
}
export function isJSXEmptyExpression(path, props) {
  return path.isJSXEmptyExpression(props);
}
export function isJSXExpressionContainer(path, props) {
  return path.isJSXExpressionContainer(props);
}
export function isJSXFragment(path, props) {
  return path.isJSXFragment(props);
}
export function isJSXIdentifier(path, props) {
  return path.isJSXIdentifier(props);
}
export function isJSXMemberExpression(path, props) {
  return path.isJSXMemberExpression(props);
}
export function isJSXNamespacedName(path, props) {
  return path.isJSXNamespacedName(props);
}
export function isJSXOpeningElement(path, props) {
  return path.isJSXOpeningElement(props);
}
export function isJSXOpeningFragment(path, props) {
  return path.isJSXOpeningFragment(props);
}
export function isJSXSpreadAttribute(path, props) {
  return path.isJSXSpreadAttribute(props);
}
export function isJSXSpreadChild(path, props) {
  return path.isJSXSpreadChild(props);
}
export function isJSXText(path, props) {
  return path.isJSXText(props);
}
export function isLVal(path, props) {
  return path.isLVal(props);
}
export function isLabeledStatement(path, props) {
  return path.isLabeledStatement(props);
}
export function isLiteral(path, props) {
  return path.isLiteral(props);
}
export function isLogicalExpression(path, props) {
  return path.isLogicalExpression(props);
}
export function isLoop(path, props) {
  return path.isLoop(props);
}
export function isMemberExpression(path, props) {
  return path.isMemberExpression(props);
}
export function isMetaProperty(path, props) {
  return path.isMetaProperty(props);
}
export function isMethod(path, props) {
  return path.isMethod(props);
}
export function isMixedTypeAnnotation(path, props) {
  return path.isMixedTypeAnnotation(props);
}
export function isModuleDeclaration(path, props) {
  return path.isModuleDeclaration(props);
}
export function isModuleSpecifier(path, props) {
  return path.isModuleSpecifier(props);
}
export function isNewExpression(path, props) {
  return path.isNewExpression(props);
}
export function isNoop(path, props) {
  return path.isNoop(props);
}
export function isNullLiteral(path, props) {
  return path.isNullLiteral(props);
}
export function isNullLiteralTypeAnnotation(path, props) {
  return path.isNullLiteralTypeAnnotation(props);
}
export function isNullableTypeAnnotation(path, props) {
  return path.isNullableTypeAnnotation(props);
}
export function isNumberLiteralTypeAnnotation(path, props) {
  return path.isNumberLiteralTypeAnnotation(props);
}
export function isNumberTypeAnnotation(path, props) {
  return path.isNumberTypeAnnotation(props);
}
export function isNumericLiteral(path, props) {
  return path.isNumericLiteral(props);
}
export function isObjectExpression(path, props) {
  return path.isObjectExpression(props);
}
export function isObjectMember(path, props) {
  return path.isObjectMember(props);
}
export function isObjectMethod(path, props) {
  return path.isObjectMethod(props);
}
export function isObjectPattern(path, props) {
  return path.isObjectPattern(props);
}
export function isObjectProperty(path, props) {
  return path.isObjectProperty(props);
}
export function isObjectTypeAnnotation(path, props) {
  return path.isObjectTypeAnnotation(props);
}
export function isObjectTypeCallProperty(path, props) {
  return path.isObjectTypeCallProperty(props);
}
export function isObjectTypeIndexer(path, props) {
  return path.isObjectTypeIndexer(props);
}
export function isObjectTypeInternalSlot(path, props) {
  return path.isObjectTypeInternalSlot(props);
}
export function isObjectTypeProperty(path, props) {
  return path.isObjectTypeProperty(props);
}
export function isObjectTypeSpreadProperty(path, props) {
  return path.isObjectTypeSpreadProperty(props);
}
export function isOpaqueType(path, props) {
  return path.isOpaqueType(props);
}
export function isOptionalCallExpression(path, props) {
  return path.isOptionalCallExpression(props);
}
export function isOptionalMemberExpression(path, props) {
  return path.isOptionalMemberExpression(props);
}
export function isParenthesizedExpression(path, props) {
  return path.isParenthesizedExpression(props);
}
export function isPattern(path, props) {
  return path.isPattern(props);
}
export function isPatternLike(path, props) {
  return path.isPatternLike(props);
}
export function isPipelineBareFunction(path, props) {
  return path.isPipelineBareFunction(props);
}
export function isPipelinePrimaryTopicReference(path, props) {
  return path.isPipelinePrimaryTopicReference(props);
}
export function isPipelineTopicExpression(path, props) {
  return path.isPipelineTopicExpression(props);
}
export function isPrivate(path, props) {
  return path.isPrivate(props);
}
export function isPrivateName(path, props) {
  return path.isPrivateName(props);
}
export function isProgram(path, props) {
  return path.isProgram(props);
}
export function isProperty(path, props) {
  return path.isProperty(props);
}
export function isPureish(path, props) {
  return path.isPureish(props);
}
export function isQualifiedTypeIdentifier(path, props) {
  return path.isQualifiedTypeIdentifier(props);
}
export function isRegExpLiteral(path, props) {
  return path.isRegExpLiteral(props);
}
export function isRestElement(path, props) {
  return path.isRestElement(props);
}
export function isReturnStatement(path, props) {
  return path.isReturnStatement(props);
}
export function isScopable(path, props) {
  return path.isScopable(props);
}
export function isSequenceExpression(path, props) {
  return path.isSequenceExpression(props);
}
export function isSpreadElement(path, props) {
  return path.isSpreadElement(props);
}
export function isStatement(path, props) {
  return path.isStatement(props);
}
export function isStringLiteral(path, props) {
  return path.isStringLiteral(props);
}
export function isStringLiteralTypeAnnotation(path, props) {
  return path.isStringLiteralTypeAnnotation(props);
}
export function isStringTypeAnnotation(path, props) {
  return path.isStringTypeAnnotation(props);
}
export function isSuper(path, props) {
  return path.isSuper(props);
}
export function isSwitchCase(path, props) {
  return path.isSwitchCase(props);
}
export function isSwitchStatement(path, props) {
  return path.isSwitchStatement(props);
}
export function isTSAnyKeyword(path, props) {
  return path.isTSAnyKeyword(props);
}
export function isTSArrayType(path, props) {
  return path.isTSArrayType(props);
}
export function isTSAsExpression(path, props) {
  return path.isTSAsExpression(props);
}
export function isTSBooleanKeyword(path, props) {
  return path.isTSBooleanKeyword(props);
}
export function isTSCallSignatureDeclaration(path, props) {
  return path.isTSCallSignatureDeclaration(props);
}
export function isTSConditionalType(path, props) {
  return path.isTSConditionalType(props);
}
export function isTSConstructSignatureDeclaration(path, props) {
  return path.isTSConstructSignatureDeclaration(props);
}
export function isTSConstructorType(path, props) {
  return path.isTSConstructorType(props);
}
export function isTSDeclareFunction(path, props) {
  return path.isTSDeclareFunction(props);
}
export function isTSDeclareMethod(path, props) {
  return path.isTSDeclareMethod(props);
}
export function isTSEntityName(path, props) {
  return path.isTSEntityName(props);
}
export function isTSEnumDeclaration(path, props) {
  return path.isTSEnumDeclaration(props);
}
export function isTSEnumMember(path, props) {
  return path.isTSEnumMember(props);
}
export function isTSExportAssignment(path, props) {
  return path.isTSExportAssignment(props);
}
export function isTSExpressionWithTypeArguments(path, props) {
  return path.isTSExpressionWithTypeArguments(props);
}
export function isTSExternalModuleReference(path, props) {
  return path.isTSExternalModuleReference(props);
}
export function isTSFunctionType(path, props) {
  return path.isTSFunctionType(props);
}
export function isTSImportEqualsDeclaration(path, props) {
  return path.isTSImportEqualsDeclaration(props);
}
export function isTSImportType(path, props) {
  return path.isTSImportType(props);
}
export function isTSIndexSignature(path, props) {
  return path.isTSIndexSignature(props);
}
export function isTSIndexedAccessType(path, props) {
  return path.isTSIndexedAccessType(props);
}
export function isTSInferType(path, props) {
  return path.isTSInferType(props);
}
export function isTSInterfaceBody(path, props) {
  return path.isTSInterfaceBody(props);
}
export function isTSInterfaceDeclaration(path, props) {
  return path.isTSInterfaceDeclaration(props);
}
export function isTSIntersectionType(path, props) {
  return path.isTSIntersectionType(props);
}
export function isTSLiteralType(path, props) {
  return path.isTSLiteralType(props);
}
export function isTSMappedType(path, props) {
  return path.isTSMappedType(props);
}
export function isTSMethodSignature(path, props) {
  return path.isTSMethodSignature(props);
}
export function isTSModuleBlock(path, props) {
  return path.isTSModuleBlock(props);
}
export function isTSModuleDeclaration(path, props) {
  return path.isTSModuleDeclaration(props);
}
export function isTSNamespaceExportDeclaration(path, props) {
  return path.isTSNamespaceExportDeclaration(props);
}
export function isTSNeverKeyword(path, props) {
  return path.isTSNeverKeyword(props);
}
export function isTSNonNullExpression(path, props) {
  return path.isTSNonNullExpression(props);
}
export function isTSNullKeyword(path, props) {
  return path.isTSNullKeyword(props);
}
export function isTSNumberKeyword(path, props) {
  return path.isTSNumberKeyword(props);
}
export function isTSObjectKeyword(path, props) {
  return path.isTSObjectKeyword(props);
}
export function isTSOptionalType(path, props) {
  return path.isTSOptionalType(props);
}
export function isTSParameterProperty(path, props) {
  return path.isTSParameterProperty(props);
}
export function isTSParenthesizedType(path, props) {
  return path.isTSParenthesizedType(props);
}
export function isTSPropertySignature(path, props) {
  return path.isTSPropertySignature(props);
}
export function isTSQualifiedName(path, props) {
  return path.isTSQualifiedName(props);
}
export function isTSRestType(path, props) {
  return path.isTSRestType(props);
}
export function isTSStringKeyword(path, props) {
  return path.isTSStringKeyword(props);
}
export function isTSSymbolKeyword(path, props) {
  return path.isTSSymbolKeyword(props);
}
export function isTSThisType(path, props) {
  return path.isTSThisType(props);
}
export function isTSTupleType(path, props) {
  return path.isTSTupleType(props);
}
export function isTSType(path, props) {
  return path.isTSType(props);
}
export function isTSTypeAliasDeclaration(path, props) {
  return path.isTSTypeAliasDeclaration(props);
}
export function isTSTypeAnnotation(path, props) {
  return path.isTSTypeAnnotation(props);
}
export function isTSTypeAssertion(path, props) {
  return path.isTSTypeAssertion(props);
}
export function isTSTypeElement(path, props) {
  return path.isTSTypeElement(props);
}
export function isTSTypeLiteral(path, props) {
  return path.isTSTypeLiteral(props);
}
export function isTSTypeOperator(path, props) {
  return path.isTSTypeOperator(props);
}
export function isTSTypeParameter(path, props) {
  return path.isTSTypeParameter(props);
}
export function isTSTypeParameterDeclaration(path, props) {
  return path.isTSTypeParameterDeclaration(props);
}
export function isTSTypeParameterInstantiation(path, props) {
  return path.isTSTypeParameterInstantiation(props);
}
export function isTSTypePredicate(path, props) {
  return path.isTSTypePredicate(props);
}
export function isTSTypeQuery(path, props) {
  return path.isTSTypeQuery(props);
}
export function isTSTypeReference(path, props) {
  return path.isTSTypeReference(props);
}
export function isTSUndefinedKeyword(path, props) {
  return path.isTSUndefinedKeyword(props);
}
export function isTSUnionType(path, props) {
  return path.isTSUnionType(props);
}
export function isTSUnknownKeyword(path, props) {
  return path.isTSUnknownKeyword(props);
}
export function isTSVoidKeyword(path, props) {
  return path.isTSVoidKeyword(props);
}
export function isTaggedTemplateExpression(path, props) {
  return path.isTaggedTemplateExpression(props);
}
export function isTemplateElement(path, props) {
  return path.isTemplateElement(props);
}
export function isTemplateLiteral(path, props) {
  return path.isTemplateLiteral(props);
}
export function isTerminatorless(path, props) {
  return path.isTerminatorless(props);
}
export function isThisExpression(path, props) {
  return path.isThisExpression(props);
}
export function isThisTypeAnnotation(path, props) {
  return path.isThisTypeAnnotation(props);
}
export function isThrowStatement(path, props) {
  return path.isThrowStatement(props);
}
export function isTryStatement(path, props) {
  return path.isTryStatement(props);
}
export function isTupleTypeAnnotation(path, props) {
  return path.isTupleTypeAnnotation(props);
}
export function isTypeAlias(path, props) {
  return path.isTypeAlias(props);
}
export function isTypeAnnotation(path, props) {
  return path.isTypeAnnotation(props);
}
export function isTypeCastExpression(path, props) {
  return path.isTypeCastExpression(props);
}
export function isTypeParameter(path, props) {
  return path.isTypeParameter(props);
}
export function isTypeParameterDeclaration(path, props) {
  return path.isTypeParameterDeclaration(props);
}
export function isTypeParameterInstantiation(path, props) {
  return path.isTypeParameterInstantiation(props);
}
export function isTypeofTypeAnnotation(path, props) {
  return path.isTypeofTypeAnnotation(props);
}
export function isUnaryExpression(path, props) {
  return path.isUnaryExpression(props);
}
export function isUnaryLike(path, props) {
  return path.isUnaryLike(props);
}
export function isUnionTypeAnnotation(path, props) {
  return path.isUnionTypeAnnotation(props);
}
export function isUpdateExpression(path, props) {
  return path.isUpdateExpression(props);
}
export function isUserWhitespacable(path, props) {
  return path.isUserWhitespacable(props);
}
export function isVariableDeclaration(path, props) {
  return path.isVariableDeclaration(props);
}
export function isVariableDeclarator(path, props) {
  return path.isVariableDeclarator(props);
}
export function isVariance(path, props) {
  return path.isVariance(props);
}
export function isVoidTypeAnnotation(path, props) {
  return path.isVoidTypeAnnotation(props);
}
export function isWhile(path, props) {
  return path.isWhile(props);
}
export function isWhileStatement(path, props) {
  return path.isWhileStatement(props);
}
export function isWithStatement(path, props) {
  return path.isWithStatement(props);
}
export function isYieldExpression(path, props) {
  return path.isYieldExpression(props);
}
export function isBindingIdentifier(path, props) {
  return path.isBindingIdentifier(props);
}
export function isBlockScoped(path, props) {
  return path.isBlockScoped(props);
}
export function isGenerated(path, props) {
  return path.isGenerated(props);
}
export function isPure(path, props) {
  return path.isPure(props);
}
export function isReferenced(path, props) {
  return path.isReferenced(props);
}
export function isReferencedIdentifier(path, props) {
  return path.isReferencedIdentifier(props);
}
export function isReferencedMemberExpression(path, props) {
  return path.isReferencedMemberExpression(props);
}
export function isScope(path, props) {
  return path.isScope(props);
}
export function isUser(path, props) {
  return path.isUser(props);
}
export function isVar(path, props) {
  return path.isVar(props);
}
